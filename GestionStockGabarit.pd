//*******************************************************
//* 
//* Author:  Automatically generated by Perfect Developer
//* Created: 09:40:25 on Friday October 8th 2010 UTC
//*******************************************************
//////////////////////////////////////////////////////////////////////////
//  TP2 - GLO-3004, Spécification formelle et vérification de logiciels, 
//////////////////////////////////////////////////////////////////////////

// Mathieu BOILY - 111 127 896
// Marc-Antoine FORTIER - 111 130 526
// Maxime LAVERGNE - 111 110 783

//-- Types de base (abstraits) -------------------------------------------
// L'énoncé n'indique aucune information concernant les attributs d'un
// il est alors normal de les considérer comme des types abstraits "tag".
// Les quantités sont naturellement des entiers naturelles. 

class Produit ^= tag;
class Quantite ^= nat;
class Niveau ^= nat;   // entre 1 et 10.

// 
//-- Constantes ----------------------------------------------------------
//  La capacité de stockage est une constante liée aux installations de l'entreprise. 
const 
	capacite : nat ^= 1000,	// Capacité maximal d'un produit
	satisfactionSeuil : nat ^= 6, 	// Niveau de satifaction minimal
	satisfactionMax : nat ^= 10, 	// Niveau de satifaction maximal
	renouvellementSeuil : nat ^= 50;	// En dessous de ce seuil, la quantité est considérée comme faible

//------------------------------------------------------------------------
// CLASSE Gestiontock
//------------------------------------------------------------------------
// L'énoncé indique clairement plusieurs attributs et propriétés relatifs
// à la gestion de  stock, il est donc normal d'y associer une classe.	
//--------------------------------------------------------------------------
class GestionStock ^= 
abstract 
	var 
		// Le stock est une association (produit, quantite)
		stock          : map of (Produit  -> Quantite),
		// Le marcheCible est un ensemble de produits.
		marcheCible    : set of (Produit),
		// Ensemble des produits si son renouvellement excede ou egale a renouvellementSeuil
		produitsPopulaires 			: set of (Produit),
		// Ensemble des produits si son renouvellement est sous renouvelleSeuil
		produitsNonPopulaires		: set of (Produit),
		// Les seuils sont fournis comme une association (produit,seuil)
		seuil          : map of (Produit -> Quantite),
		// Le renouvellement est un registre dans lequel on recense les quantites achetees de chacun des produits
		renouvellement : map of (Produit -> nat),
		// Associe chaque produit a un niveaeu de satisfaction
		satisfaction				: map of (Produit -> Niveau), 
		// true si la ligne de produits va etre fermee par le gestionnaire
		fermeture					: bool;
	invariant
		// Les produits en stock doivent faire partie du marche cibe. 
		stock.dom <<= marcheCible, 
		// Le domaine de seuil est le même que le domaine de stock, à chaque produit en stock on associe un seuil. 
		seuil.dom =  stock.dom,
		// Un renouvellement est associé à chacun des produits en stock.
		renouvellement.dom = stock.dom,
		// La quantité de chacun des produits ne doit pas dépasser la capacité de stockage fixée d'avance
		forall p::stock.dom :- stock[p] <= capacite,
		// Les seuils ne doivent pas être plus élevés que la capacité de stockage (déduction logique!)
		forall p::seuil.dom :-  seuil[p] <= capacite,
		// La quantité en stock de chaque produit doit être supérieur ou égal au seuil minimal associé au produit et inférieure ou égal à la capacité.
		forall p::stock.dom :- seuil[p] <= stock[p];

interface
	// Puisqu'on passe des paramètres lors de l'initialisation. Il faut s'assurer qu'ils sont conformes aux invariants. 
	build{	!stock 					: map of (Produit -> Quantite), 
			!marcheCible 			: set of (Produit), 
			!produitsPopulaires 	: set of (Produit),
			!produitsNonPopulaires 	: set of (Produit), 
			!seuil 					: map of (Produit -> Quantite),
			!renouvellement			: map of (Produit -> Quantite),
			!satisfaction 			: map of (Produit -> Niveau), 
			!fermeture 				: bool}
	pre
		// On ne fonctionne pas avec une ligne de produits vide
		#marcheCible > 0,
		// Les produits en stock doivent faire partie de la ligne de produits
		stock.dom <<= marcheCible,
		seuil.dom = stock.dom,
		// La quantite d’un produit en stock ne doit pas exceder capacite
		forall p::stock.dom :- stock[p] <= capacite,
		// Le seuil d’un produit en stock ne doit pas exceder capacite
		forall p::seuil.dom :- seuil[p] <= capacite,
		// La quantite d’un produit en stock doit etre au moins egale au seuil associe a ce produit
		forall p::stock.dom :- stock[p] >= seuil[p],
		
		produitsPopulaires = stock.dom,
		produitsNonPopulaires = set of (Produit){},
		renouvellement = map of (Produit -> nat) {for p ::stock.dom yield pair of (Produit, nat){p,0}},
		satisfaction = map of (Produit -> Niveau){},
		fermeture = false;

// -----------------------------
// 1.
// achatProduitExistant
//		Pour pouvoir acheter une quantité q d'un produit existant, 
// 		Il faut s'assurer que le produit est en stock
// 		Il faut s'assurer que le total de la quantité existante plus celle qu'on achète reste 
// 		inférieure ou égale à la capacité
// -----------------------------  
	schema !achatProduitExistant(p:Produit,q:Quantite)
		pre 
		  p in stock.dom,
		  stock[p]+q <= capacite,
		  fermeture = false
		post 
		   stock! = (stock.remove(p)).append(p -> stock[p]+q),
		   renouvellement! = (renouvellement.remove(p)).append(p -> renouvellement[p]+q);

// -----------------------------
// 2.
// achatNouveauProduit
// 		Il faut s'assurer que le produit fait partie du marché cible   
// 		Pour pouvoir acheter une quantité q d'un produit p non existant en stock, 
// 		Il faut fournir le seuil  minimal et il faut s'assurer 
// 		qu'il est inférieur ou égal à la capacité                                                               
// 		Il faut s'assurer que la quantité  qu'on achète est    
// 		inférieure ou égale à la capacité et supérieure ou égal au seuil 
// -----------------------------                                              
	schema !achatNouveauProduit(p:Produit,q:Quantite,s:Quantite,n:Niveau)																			   
		pre
		  p in marcheCible,																				
		  p ~in stock.dom,
		  q <= capacite,
		  s <= capacite,
		  s <= q,
		  n > satisfactionSeuil,
		  n <= satisfactionMax,
		  fermeture = false
		post
		   stock! = stock.append(p -> q),
		   seuil! = seuil.append(p -> s),
		   satisfaction! = satisfaction.append(p -> n),
		   renouvellement! = renouvellement.append(p -> 0);
 
// -----------------------------
// 3.
// venteProduit
// 		Il faut s'assurer que le produit fait partie du stock  
// 		Pour pouvoir vendre une quantité q d'un produit p existant en stock, 
// 		Il faut que q soit inférieure ou égale à la capacité 
// 		Il faut s'assurer que la quantité qui resterait aprés la vente soit supérieure ou égal au seuil
// -----------------------------
	schema !venteProduit(p:Produit,q:Quantite)
		pre 
		  p in stock.dom,
		  q <= capacite,
		  seuil[p] <= stock[p]-q,
		  fermeture = false
		post 
		   stock! = (stock.remove(p)).append(p -> (stock[p]-q));     
   
// -----------------------------
// 4.
// venteProduitAchat
// 		Il faut s'assurer que le produit fait partie du stock  
// 		Pour pouvoir vendre une quantité q  qui fait baisser le stock en deçà du seuil
// 		Il faut s'assurer que la quantité q vendue soit inférieure ou éagle à capacité moins le seuil minimal
// 		Il faut commencer par acheter le maximum possible (capacité - stock[p]) puis vendre q. 
// -----------------------------
	schema !venteProduitAchat(p:Produit,q:Quantite)
		pre 
		  p in stock.dom,
		  p in produitsPopulaires,
		  stock[p]-q < seuil[p],
		  q <= capacite-seuil[p],
		  fermeture = false
		post 
			!achatProduitExistant(p,(capacite-stock[p])) then !venteProduit(p,q)
			assert
				stock' = stock;

// -----------------------------
// produitsPopulaires
// 		Il faut récupérer les produits dont le renouvellement est supérieur ou égal à q
// -----------------------------
	schema produitsPopulaires(pp!: set of (Produit),q:Quantite)
		pre
			pp <<= stock.dom
		post 
			 pp! = (those p::renouvellement.dom :- renouvellement[p] >= q);  
	 
// -----------------------------
// 5.
// miseAJourRenouvellement
// 		Mise a jour de la popularite des produits selon le renouvellement.
// -----------------------------
	 schema !miseAJourRenouvellement(produits!: map of (Produit -> Quantite))
		pre
			renouvellement.dom <<= produits.dom,
			produits.dom <<= stock.dom
		post
			produitsPopulaires! = (those p::renouvellement.dom :- produits[p] >= renouvellementSeuil),
			produitsNonPopulaires! = (those p::renouvellement.dom :- produits[p] < renouvellementSeuil),
			stock! = map of (Produit -> Quantite){those p::stock.pairs :- p.x in produitsPopulaires | p.x in produitsNonPopulaires};
	 
// -----------------------------
// 6.
// miseAJourSeuils
// Mise a jour des seuils, on fournit une association produit quantite minimale de stockage.
// On associe a un produit le seuil fourni ou bien zero s’il n’est pas populaire et si son niveau
// de satisfaction est plus bas que le seuil de satisfaction.
//		P représente une association entre un produit et sa quantité minimale de stockage
//		On associe à un produit le seuil fourni (Quantite) ou bien zéro si le produit n'est pas populaire
//		Et si son niveau de satisfaction est inférieur au seuil de satisfaction
// -----------------------------
	schema !miseAJourSeuils(p : map of (Produit -> Quantite))
		pre
			p.dom <<= stock.dom
		post
			forall produit::seuil.dom :- ([satisfaction[produit] >= satisfactionSeuil]: seuil[produit]! = p[produit],
										  [renouvellement[produit] >= renouvellementSeuil]: seuil[produit]! = p[produit],
										  []: seuil[produit]! = 0),
			stock! = map of (Produit -> Quantite){(those paire::stock.pairs :- paire.y > 0)},
			fermeture! = ~(#(stock.dom) > 0);
			
										  
// -----------------------------
// 7.
// miseAJourSatisfactionSondage
//		P représente une association entre un produit et son niveau de satisfaction
//		On associe à un produit la satisfaction fournie (Niveau) en lien avec le paramètre d'entrée
// -----------------------------
	schema !miseAJourSatisfactionSondage(p : map of (Produit -> Niveau))
		pre
			p.dom <<= stock.dom
		post
			forall produit::satisfaction.dom :- satisfaction[produit]! = p[produit];
			
			
// -----------------------------
// 8.
// retirerProduit
// Le gerant peut decider de retirer un produit du marche cible. Il ne faut pas que ce produit soit 
// en stock et il faut laisser au moins un produit dans le marche cible.
//		P représente le produit à retirer
// -----------------------------
	schema !retirerProduit(p : Produit)
		pre
			p in marcheCible,
			p ~in stock.dom,
			#marcheCible > 1
		post
			marcheCible! = marcheCible.remove(p);
end;

// End.
