//*******************************************************
//* 
//* Author:  Automatically generated by Perfect Developer
//* Created: 09:40:25 on Friday October 8th 2010 UTC
//*******************************************************
//////////////////////////////////////////////////////////////////////////
//  TP2 - GLO-3004, Spécification formelle et vérification de logiciels, 
//////////////////////////////////////////////////////////////////////////

// Mathieu BOILY - 111 127 896
// Marc-Antoine FORTIER - 111 130 526
// Maxime LAVERGNE - 111 110 783

//-- Types de base (abstraits) -------------------------------------------
// L'énoncé n'indique aucune information concernant les attributs d'un
// il est alors normal de les considérer comme des types abstraits "tag".
// Les quantités sont naturellement des entiers naturelles. 

class Produit ^= tag;  // Type abstrait. Représente un produit entreposé dans les stocks
class Quantite ^= nat; // Entier naturel devant être inférieur ou égal à la constante "capacite"
class Niveau ^= nat;   // Entier naturel pouvant varier entre 1 et 10 inclusivement.

// 
//-- Constantes ----------------------------------------------------------
//  La capacité de stockage est une constante liée aux installations de l'entreprise. 
const 
	capacite : nat ^= 1000,				// Entier naturel représentant le nombre maximal d'exemplaires d'un produit en stock.
	satisfactionSeuil : nat ^= 6, 		// Entier naturel représentant le niveau de satifaction minimal pour que le produit soit considéré populaire.
	satisfactionMax : nat ^= 10, 		// Entier naturel représentant le niveau de satifaction maximal que peut prendre un produit.
	renouvellementSeuil : nat ^= 50;	// Entier naturel. En dessous de ce seuil, la quantité est considérée comme faible.

//------------------------------------------------------------------------
// CLASSE GestionStock
//------------------------------------------------------------------------
// L'énoncé indique clairement plusieurs attributs et propriétés relatifs
// à la gestion de stock, il est donc normal d'y associer une classe.	
// La classe peut être vue comme un entrepôt qui gère la distribution de produits à une clientèle cible.
//--------------------------------------------------------------------------
class GestionStock ^= 
abstract 
	var 
		// Le stock est une association prenant un produit en paramètre et en retourne la quantité disponible.
		stock          			: map of (Produit  -> Quantite),
		// Le marcheCible est un ensemble de produits qui satisfont la clientèle cible.
		marcheCible    			: set of (Produit),
		// Ensemble des produits dont leur renouvellement excède ou égale a renouvellementSeuil.
		produitsPopulaires 		: set of (Produit),
		// Ensemble des produits dont leur renouvellement est inférieur à renouvellementSeuil.
		produitsNonPopulaires	: set of (Produit),
		// Les seuils sont fournis comme une association prenant en paramètre un produit et qui retourne la quantité minimale sous lequel on doit renouveller sa quantité
		seuil          			: map of (Produit -> Quantite),
		// Le renouvellement est un registre dans lequel on recense les quantités achetées de chacun des produits. Il s'agit d'une association d'un produit vers un naturel.
		renouvellement 			: map of (Produit -> nat),
		// Association prenant en paramètre un produit et qui retourne le niveau de satisfaction de celui-ci.
		satisfaction			: map of (Produit -> Niveau), 
		// Variable booléenne qui indique si la ligne de produits va être fermée par le gestionnaire ou non.
		fermeture				: bool;
	invariant
		// Les produits en stock doivent faire partie du marche cibe. 
		stock.dom <<= marcheCible, 
		// Le domaine de seuil est le même que le domaine de stock, à chaque produit en stock on associe un seuil. 
		seuil.dom = stock.dom,
		// Un renouvellement est associé à chacun des produits en stock.
		renouvellement.dom = stock.dom,
		// Une satisfaction est associée à chacun des produits en stock.
		satisfaction.dom = stock.dom,
		// La quantité d’un produit en stock ne doit pas excéder la capacité.
		forall p::stock.dom :- stock[p] <= capacite,
		// Le seuil d’un produit en stock ne doit pas excéder capacite
		forall p::seuil.dom :- seuil[p] <= capacite,
		// La quantité en stock de chaque produit doit être au moins égale au seuil associé a ce produit
		forall p::stock.dom :- seuil[p] <= stock[p];

interface
	// Puisqu'on passe des paramètres lors de l'initialisation. Il faut s'assurer qu'ils sont conformes aux invariants. 
	build{	!stock 					: map of (Produit -> Quantite), 
			!marcheCible 			: set of (Produit), 
			!produitsPopulaires 	: set of (Produit),
			!produitsNonPopulaires 	: set of (Produit), 
			!seuil 					: map of (Produit -> Quantite),
			!renouvellement			: map of (Produit -> Quantite),
			!satisfaction 			: map of (Produit -> Niveau), 
			!fermeture 				: bool}
	pre
		// On ne fonctionne pas avec une ligne de produits vide
		#marcheCible > 0,
		// Les produits en stock doivent faire partie de la ligne de produits
		stock.dom <<= marcheCible,
		seuil.dom = stock.dom,
		renouvellement.dom = stock.dom,
		satisfaction.dom = stock.dom,
		// La quantité d'exmeplaires d’un produit en stock ne doit pas excéder la capacité maximale
		forall p::stock.dom :- stock[p] <= capacite,
		// Le seuil d’un produit en stock ne doit pas excéder la capacité maximale
		forall p::seuil.dom :- seuil[p] <= capacite,
		// La quantité d'exemplaires d’un produit en stock doit être au moins égale au seuil associé à ce produit
		forall p::stock.dom :- stock[p] >= seuil[p],
		
		// Au départ, tous les produits sont considérés populaires par le gestionnaire
		produitsPopulaires = stock.dom,
		// Donc l'ensemble des produits non populaires doit être vide
		produitsNonPopulaires = set of (Produit){},
		// Initialisation du seuil de chaque produit
		seuil = map of (Produit -> nat) {for p::stock.dom yield pair of (Produit, nat){p,renouvellementSeuil}},
		// Initialisation de l'indice de renouvellement de chaque produit
		renouvellement = map of (Produit -> nat) {for p::stock.dom yield pair of (Produit, nat){p,0}},
		// Initialisation du niveau de satisfaction de chaque produit
		satisfaction = map of (Produit -> Niveau){for p::stock.dom yield pair of (Produit, nat){p,satisfactionSeuil}},
		// Au départ, la ligne de produit n'est pas en fermeture
		fermeture = false;

// -----------------------------
// 1.
// achatProduitExistant
//		Pour pouvoir acheter une quantité q d'un produit existant, 
// 		Il faut s'assurer que le produit est en stock
// 		Il faut s'assurer que le total de la quantité existante plus celle qu'on achète reste 
// 		inférieure ou égale à la capacité
// -----------------------------  
	schema !achatProduitExistant(p:Produit,q:Quantite)
		pre 
		  p in stock.dom,
		  stock[p]+q <= capacite,
		  fermeture = false
		post 
		   stock! = (stock.remove(p)).append(p -> stock[p]+q),
		   renouvellement! = (renouvellement.remove(p)).append(p -> renouvellement[p]+q);

// -----------------------------
// 2.
// achatNouveauProduit
// 		Il faut s'assurer que le produit fait partie du marché cible   
// 		Pour pouvoir acheter une quantité q d'un produit p non existant en stock, 
// 		Il faut fournir le seuil  minimal et il faut s'assurer 
// 		qu'il est inférieur ou égal à la capacité                                                               
// 		Il faut s'assurer que la quantité  qu'on achète est    
// 		inférieure ou égale à la capacité et supérieure ou égal au seuil 
// -----------------------------                                              
	schema !achatNouveauProduit(p:Produit,q:Quantite,s:Quantite,n:Niveau)																			   
		pre
		  p in marcheCible,																				
		  p ~in stock.dom,
		  p ~in satisfaction.dom,
		  q <= capacite,
		  s <= capacite,
		  s <= q,
		  satisfactionSeuil < n <= satisfactionMax,
		  fermeture = false
		post
		   stock! = stock.append(p -> q),
		   seuil! = seuil.append(p -> s),
		   satisfaction! = satisfaction.append(p -> n),
		   renouvellement! = renouvellement.append(p -> 0);
 
// -----------------------------
// 3.
// venteProduit
// 		Il faut s'assurer que le produit fait partie du stock  
// 		Pour pouvoir vendre une quantité q d'un produit p existant en stock, 
// 		Il faut que q soit inférieure ou égale à la capacité 
// 		Il faut s'assurer que la quantité qui resterait aprés la vente soit supérieure ou égal au seuil
// -----------------------------
	schema !venteProduit(p:Produit,q:Quantite)
		pre 
		  p in stock.dom,
		  q <= capacite,
		  seuil[p] <= stock[p]-q,
		  fermeture = false
		post 
		   stock! = (
				[(stock[p]-q)=0]:
					stock.remove(p),
				[]:
					(stock.remove(p)).append(p -> (stock[p]-q))
			),
		   fermeture! = (#(stock'.dom) = 0),
		   seuil! = seuil**(stock'.dom),
		   renouvellement! = renouvellement**(stock'.dom),
		   satisfaction! = satisfaction**(stock'.dom);
   
// -----------------------------
// 4.
// venteProduitAchat
// 		Il faut s'assurer que le produit fait partie du stock  
// 		Pour pouvoir vendre une quantité q  qui fait baisser le stock en deçà du seuil
// 		Il faut s'assurer que la quantité q vendue soit inférieure ou éagle à capacité moins le seuil minimal
// 		Il faut commencer par acheter le maximum possible (capacité - stock[p]) puis vendre q. 
// -----------------------------
	schema !venteProduitAchat(p:Produit,q:Quantite)
		pre 
		  p in stock.dom,
		  p in produitsPopulaires,
		  stock[p]-q < seuil[p],
		  q <= capacite-seuil[p],
		  fermeture = false
		post 
			!achatProduitExistant(p,(capacite-stock[p])) then !venteProduit(p,q);

// -----------------------------
// produitsPopulaires
// 		Il faut récupérer les produits dont le renouvellement est supérieur ou égal à q
// -----------------------------
	schema produitsPopulaires(pp!: set of (Produit),q:Quantite)
		pre
			pp <<= stock.dom
		post 
			 pp! = (those p::renouvellement.dom :- renouvellement[p] >= q);  
	 
// -----------------------------
// 5.
// miseAJourRenouvellement
// 		Mise a jour de la popularite des produits selon le renouvellement.
// -----------------------------
	 schema !miseAJourRenouvellement(produits: map of (Produit -> Quantite))
		pre
			renouvellement.dom <<= produits.dom,
			produits.dom <<= stock.dom
		post
			produitsPopulaires! = (those p::renouvellement.dom :- produits[p] >= renouvellementSeuil),
			produitsNonPopulaires! = (those p::renouvellement.dom :- produits[p] < renouvellementSeuil),
			stock! = map of (Produit -> Quantite){those p::stock.pairs :- p.x in produitsPopulaires | p.x in produitsNonPopulaires},
			seuil! = seuil**(stock'.dom),
			renouvellement! = renouvellement**(stock'.dom),
			satisfaction! = satisfaction**(stock'.dom);
	 
// -----------------------------
// 6.
// miseAJourSeuils
// Mise a jour des seuils, on fournit une association produit quantite minimale de stockage.
// On associe a un produit le seuil fourni ou bien zero s’il n’est pas populaire et si son niveau
// de satisfaction est plus bas que le seuil de satisfaction.
//		P représente une association entre un produit et sa quantité minimale de stockage
//		On associe à un produit le seuil fourni (Quantite) ou bien zéro si le produit n'est pas populaire
//		Et si son niveau de satisfaction est inférieur au seuil de satisfaction
// -----------------------------
	schema !miseAJourSeuils(produits: map of (Produit -> Quantite))
		pre
			produits.dom <<= seuil.dom,
			forall p::produits.dom :- produits[p] <= stock[p] <= capacite
		post
			forall p::produits.dom :- (
				[satisfaction[p] >= satisfactionSeuil | renouvellement[p] >= renouvellementSeuil]:
					seuil[p]! = produits[p],
				[]:
					seuil[p]! = 0
			);
			
										  
// -----------------------------
// 7.
// miseAJourSatisfactionSondage
//		P représente une association entre un produit et son niveau de satisfaction
//		On associe à un produit la satisfaction fournie (Niveau) en lien avec le paramètre d'entrée
// -----------------------------
	schema !miseAJourSatisfactionSondage(produits: map of (Produit -> Niveau))
		pre
			produits.dom <<= satisfaction.dom
		post
			forall p::produits.dom :- satisfaction[p]! = produits[p];
			
// -----------------------------
// 8.
// retirerProduit
// Le gerant peut decider de retirer un produit du marche cible. Il ne faut pas que ce produit soit 
// en stock et il faut laisser au moins un produit dans le marche cible.
//		P représente le produit à retirer
// -----------------------------
	schema !retirerProduit(produit: Produit)
		pre
			produit in marcheCible,
			produit ~in stock.dom,
			#marcheCible > 1
		post
			marcheCible! = marcheCible.remove(produit);
end;

// End.
